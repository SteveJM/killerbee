#!/usr/bin/env python

'''
Requires TWO zigbee devices.
Device 1: Is used to scan for active channels. This device must support
packet injection.
device 2: Is tasked with capturing packets for active channels. If the
active channel changes then capturing will terminate and resume on the new channel.

Captures are written in PCAP format to files named YYYYMMDD-HHMMSS-chanXX.pcap.
'''

import sys
import os
import json
import signal
import datetime
import time
import argparse
import threading
try:
    import gpsPoll
except:
    print ('GPS module not found - not loading')

from killerbee import *

txcount = 0
rxcount = 0
stumbled = {}
active = None

class captureThread(threading.Thread):
    def __init__(self, args, kb, pcapfile, channel):
        super(captureThread, self).__init__()
        self.channel = channel
        self.pcapfile = pcapfile
        self.args = args
        self.kb = kb
        self.shutdown_flag = threading.Event()

    def stop(self):
        self.shutdown_flag.set()

    def run(self):
        pd = None

        if self.args.pan_id_hex:
            panid = int(args.pan_id_hex, 16)
        else:
            panid = 0

        try:
            if not self.kb.is_valid_channel(self.channel, self.args.subghz_page):
                print("ERROR: Must specify a valid IEEE 802.15.4 channel for the selected device.")
            else:
                self.kb.set_channel(self.channel)
                self.kb.sniffer_on()

                #rf_freq_mhz = (args.channel - 10) * 5 + 2400
                rf_freq_mhz = self.kb.frequency(self.channel, self.args.subghz_page) / 1000.0
                print("zbdump: listening on \'{0}\', channel {1}, page {2} ({3} MHz), link-type DLT_IEEE802_15_4, capture size 127 bytes".format(self.kb.get_dev_info()[0], self.channel, self.args.subghz_page, rf_freq_mhz))

                pd = PcapDumper(DLT_IEEE802_15_4, self.pcapfile, ppi=self.args.ppi)
                packetcount = 0

                while not self.shutdown_flag.is_set():
                    packet = self.kb.pnext()
                    # packet[1] is True if CRC is correct, check removed to have promiscous capture regardless of CRC
                    # if PAN filter active, only process correct PAN or ACK
                    if packet and panid:
                        pan, layer = kbgetpanid(Dot15d4FCS(packet['bytes']))
                    if packet != None and (not panid or panid == pan): # and packet[1]:
                        packetcount += 1
                        pd.pcap_dump(packet['bytes'], ant_dbm=packet['dbm'], freq_mhz=rf_freq_mhz)

                print("Closing packet dump...")
                pd.close()
                self.kb.sniffer_off()
                print("%d packets captured to %s" % (packetcount, self.pcapfile))
        except Exception as error:
            print("Terminating Packet Capture due to error: {0}".format(error))
            if pd is not None:
                pd.close()
                self.kb.sniffer_off()
            self.shutdown_flag.set()


class ServiceExit(Exception):
    """
    Custom exception which is used to trigger the clean exit
    of all running threads and the main program.
    """
    pass


def display_details(routerdata):
    global args, csvfile, jsonfile, gpsp

    stackprofile_map = {0:"Network Specific",
                        1:"ZigBee Standard",
                        2:"ZigBee Enterprise"}
    stackver_map = {0:"ZigBee Prototype",
                    1:"ZigBee 2004",
                    2:"ZigBee 2006/2007"}
    spanid, source, extpanid, stackprofilever, channel = routerdata
    stackprofile = ord(stackprofilever) & 0x0f
    stackver = (ord(stackprofilever) & 0xf0) >>4

    print("New Network: PANID 0x%02X%02X  Source 0x%02X%02X"%(ord(spanid[0]), ord(spanid[1]), ord(source[0]), ord(source[1])))

    try:
        extpanidstr=""
        for ind in range(0,7):
            extpanidstr += "%02x:"%ord(extpanid[ind])
        extpanidstr += "%02X"%ord(extpanid[-1])
        sys.stdout.write("\tExt PANID: " + extpanidstr)
    except IndexError:
        sys.stdout.write("\tExt PANID: Unknown")

    try:
        sys.stdout.write("\tStack Profile: " + stackprofile_map[stackprofile])
        stackprofilestr = stackprofile_map[stackprofile]
    except KeyError:
        print("\tStack Profile: Unknown (%d)"%stackprofile)
        stackprofilestr = "Unknown (%d)"%stackprofile

    try:
        sys.stdout.write("\tStack Version: " + stackver_map[stackver])
        stackverstr = stackver_map[stackprofile]
    except KeyError:
        print("\tStack Version: Unknown ({0})".format(stackver))
        stackverstr = "Unknown (%d)"%stackver

    print("\tChannel: {0}".format(channel))
    gpsData = gpsp.get_current_value()

    if csvfile is not None:
        if hasattr(gpsData, 'time'):
            csvfile.write("%s,%f,%f,%f,0x%02X%02X,0x%02X%02X,%s,%s,%s,%d\n"%(gpsData.time,gpsData.lon,gpsData.lat,gpsData.alt,ord(spanid[0]), ord(spanid[1]), ord(source[0]), ord(source[1]), extpanidstr, stackprofile, stackver, channel))
        else:
            csvfile.write("Unknnown,0.0,0.0,0x%02X%02X,0x%02X%02X,%s,%s,%s,%d\n"%(ord(spanid[0]), ord(spanid[1]), ord(source[0]), ord(source[1]), extpanidstr, stackprofile, stackver, channel))
        csvfile.flush()

    if jsonfile is not None:
        jsonData = {}
        jsonData['panid'] = ord(spanid[0]) * 256 + ord(spanid[1])
        jsonData['extpanid'] = extpanidstr
        jsonData['stackprofile'] = stackprofile
        jsonData['stackver'] = stackver
        if hasattr(gpsData, 'time'):
            jsonData['timestamp'] = gpsData.time,
            jsonData['lat'] = gpsData.lat
            jsonData['lon'] = gpsData.lon
            jsonData['alt'] = gpsData.altA

        j = json.dumps(jsonData)
        print (j)
        print >> jsonfile, j
        jsonfile.flush()


def response_handler(kbCapture, stumbled, packet, channel):
    global args, active, activeExtPanId
    d154 = Dot154PacketParser()
    # Chop the packet up
    pktdecode = d154.pktchop(packet)

    # Byte-swap the frame control field
    fcf = struct.unpack("<H", pktdecode[0])[0]

    # Check if this is a beacon frame
    if (fcf & DOT154_FCF_TYPE_MASK) == DOT154_FCF_TYPE_BEACON:
        # The 6th element offset in the Dot154PacketParser.pktchop() method
        # contains the beacon data in its own list.  Extract the Ext PAN ID.
        spanid = pktdecode[4][::-1]
        source = pktdecode[5][::-1]
        beacondata = pktdecode[6]
        extpanid = beacondata[6][::-1]
        stackprofilever = beacondata[4]
        assocPermit = struct.unpack("<H", beacondata[0])[0] & 0x8000 == 0x8000
        if assocPermit:
            assoc = " ### Permitting New Associations ###"
        else:
            assoc = ""

        key = ''.join([spanid, source])
        value = [spanid, source, extpanid, stackprofilever, channel]
        if not key in stumbled:
            if args.verbose:
                print("Beacon represents new network!" + assoc)
                #print hexdump(packet)
                #print pktdecode
            stumbled[key] = value
            display_details(value)
        else:
            if args.verbose:
                print("Received beacon response." + assoc);

        if (active is None or activeExtPanId != extpanid):
            if (active is not None):
                print("Kill capture, wait for it to die.")
                active.stop()
                active.join()
                activeExtPanId = []

            captureName = args.outdir + os.sep + str(datetime.now().strftime("%Y%m%d-%H%M%S-Chan") + "%02d" % (channel))
            print("Start capture on channel %d to: %s" % (channel, captureName))
            active = captureThread(args, kbCapture, captureName, channel)
            active.start()
            activeExtPanId = extpanid
            time.sleep(2)    # Allow time for capture thread to start (Ugh!)

        return value

    if args.verbose:
        print("Received frame is not a beacon (FCF={0}).".format(pktdecode[0].encode('hex')))

    return None

def interrupt(signum, frame):
    raise ServiceExit

if __name__ == '__main__':
    csvfile = None
    jsonfile = None

    # Command-line arguments
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-1', '--scaniface', action='store', dest='scaniface',
                        help="ZigBee Device to use for Scanning (Required)")
    parser.add_argument('-2', '--pcapifact', action='store', dest='pcapiface',
                        help="ZigBee Device to use for Packet Capture (Required)")
    parser.add_argument('-g', '--gps', '--ignore', action='append', dest='ignore',
                        help="Include coordinates from GPS Device in log")
    parser.add_argument('-o', '--outdir', action='store', dest='outdir',
                        help="Output directory for Packet Capture files (Required)")
    parser.add_argument('-d', '--delay', action='store', type=float, dest='delay', default=2.0,
                        help="Delay in seconds to wait for beason response (float), default 2.0")
    parser.add_argument('-p', '--ppi', action='store_true',
                        help="??? what does gthis do ???")
    parser.add_argument('-P', '--pan_id_hex', action='store', default=None,
                        help="PanID to capture, default Any")
    parser.add_argument('-s', '--subghz_page', action='store', type=int, default=0,
                        help="??? Add description ???", )
    parser.add_argument('-v', '--verbose', action='store_true',
                        help="Print commentary to stdout, default on")
    parser.add_argument('-w', '--file', action='store', dest='logfile', default=None,
                        help="Write log of identified networks to file, default off")
    parser.add_argument('-f', '--format', action='store', dest='format', default='JSON',
                        help="Log file format: 'CSV' or 'JSON' (default)")
    parser.add_argument('-D', action='store_true', dest='showdev',
                        help="Print list of available ZigBee devices and exit")
    args = parser.parse_args()

    if args.showdev:
        show_dev()
        sys.exit(0)

    if args.logfile is not None:
        try:
            if args.format.lower() == 'csv':
                if not os.path.isFile(args.logfile):
                    writeHeader = True
                # Check if file exists and open for appending if it does...
                csvfile = open(args.logfile, 'a+')
                if writeHeader:
                    csvfile.write("time,lat,lon,panid,source,extpanid,stackprofile,stackversion,channel\n")
            else:
                jsonfile = open(args.logfile, 'a+')
        except Exception as e:
            print("Issue opening output log file: {0}.".format(e))

    if args.ignore[0] == 'IGNORE':
        print('Ignoring GPS as instructed')
    else:
        # Start the GPS Thread
        gpsp = gpsPoll.GpsPoller()
        gpsp.start()

    beacon = "\x03\x08\x00\xff\xff\xff\xff\x07"
    # Immutable strings - split beacon around sequence number field
    beaconp1 = beacon[0:2]
    beaconp2 = beacon[3:]

    try:
        kbSniff = KillerBee(device=args.scaniface)
        kbCapture = KillerBee(device=args.pcapiface)
    except KBInterfaceError as e:
        print("Interface Error: {0}".format(e))
        sys.exit(-1)

    signal.signal(signal.SIGINT, interrupt)
    print("zbstumbler: Scanning on interface \'{0}\'".format(kbSniff.get_dev_info()[0]))

    # Sequence number of beacon request frame
    seqnum = 0

    # Start of Channel 11
    channel = 11
    activeExtPanId = []

    try:
        # Loop Scanning for an active Channel
        while 1:
            if channel > 26:
                channel = 11

            if channel == 11 and args.verbose:
                gpsData = gpsp.get_current_value()
                if hasattr(gpsData, 'time'):
                    print("Current: %s, Location: %f, %f"%(gpsData.time, gpsData.lat, gpsData.lon))

            if seqnum > 255:
                seqnum = 0

            if args.verbose:
                print("Setting channel to {0}.".format(channel))
            try:
                kbSniff.set_channel(channel)
            except Exception as e:
                print("ERROR: Failed to set channel to {0}. ({1})".format(channel, e))
                sys.exit(-1)

            if args.verbose:
                print("Transmitting beacon request.")

            beaconinj = ''.join([beaconp1, "%c" % seqnum, beaconp2])

            # Process packets for arg_delay seconds looking for the beacon response frame.
            start = time.time()

            try:
                txcount+=1
                kbSniff.inject(beaconinj)
            except Exception as e:
                print("ERROR: Unable to inject packet: {0}".format(e))
                pass

            while (start+args.delay > time.time()):
                # Does not block
                try:
                    recvpkt = kbSniff.pnext()
                    # Check for empty packet (timeout) and valid FCS
                    if recvpkt != None and recvpkt[1]:
                        rxcount += 1
                        if args.verbose:
                            print("Received frame.")#, time.time()-start
                        networkdata = response_handler(kbCapture, stumbled, recvpkt[0], channel)
                except Exception as e:
                    print("ERROR: Unable to read sniff response: {0}".format(e))
                    pass

            kbSniff.sniffer_off()
            seqnum += 1
            channel += 1

    except ServiceExit:
        if active:
            active.stop()
            active.join()
        gpsp.stop()
        gpsp.join()
        if csvfile is not None:
            csvfile.close()
        if jsonfile is not None:
            jsonfile.close()
        kbSniff.close()
        kbCapture.close()
        print("\n{0} packets transmitted, {1} responses.".format(txcount, rxcount))
        sys.exit(0)
